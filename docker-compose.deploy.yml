version: '3.8'

services:
  app:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: vector_meme_app_all
    env_file:
      - .env
    ports:
      - "${HOST_APP_PORT:-8000}:8000" # FastAPI application port
    volumes:
      # Optional: Mount logs and run directories from the container to the host
      # This can be useful for inspecting logs/pids generated by start_dev_services.sh
      - ./logs:/app/logs
      - ./run:/app/run
      # Optional: Mount raw_images if your app needs to access it directly from filesystem
      # - ./raw_images:/app/raw_images
    networks:
      - app_network
    depends_on:
      postgres_db:
        condition: service_started # Assuming no healthcheck in basic postgres image
      minio:
        condition: service_started # MinIO official image does not have a healthcheck by default
      redis:
        condition: service_started # Redis official image does not have a healthcheck by default
      milvus_standalone:
        condition: service_healthy # Milvus has a healthcheck defined

  postgres_db:
    image: postgres:15-alpine
    container_name: test_postgres_db_all
    environment:
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      POSTGRES_DB: ${POSTGRES_DB}
    ports:
      - "${HOST_POSTGRES_PORT:-5432}:5432"
    volumes:
      - postgres_data_all:/var/lib/postgresql/data
    networks:
      - app_network
    restart: unless-stopped

  minio:
    image: minio/minio:RELEASE.2023-09-07T02-05-02Z
    container_name: test_minio_all
    environment:
      MINIO_ROOT_USER: ${MINIO_ROOT_USER}
      MINIO_ROOT_PASSWORD: ${MINIO_ROOT_PASSWORD}
      # MINIO_DEFAULT_BUCKETS: ${MINIO_DEFAULT_BUCKETS} # Buckets are usually created by app or mc
    ports:
      # API port 9000 will now be exposed via Nginx
      - "${HOST_MINIO_CONSOLE_PORT:-9001}:9001" # MinIO Console can still be directly exposed
    volumes:
      - minio_data_all:/data
    command: server /data --console-address ":9001"
    networks:
      - app_network
    restart: unless-stopped

  redis:
    image: redis:7-alpine
    container_name: test_redis_all
    ports:
      - "${HOST_REDIS_PORT:-6379}:6379"
    volumes:
      - redis_data_all:/data
    networks:
      - app_network
    restart: unless-stopped

  milvus_standalone:
    image: milvusdb/milvus:v2.5.12 # Using the version from the original docker-compose
    container_name: milvus_standalone_service_all
    security_opt:
      - "seccomp:unconfined"
    environment:
      ETCD_USE_EMBED: ${ETCD_USE_EMBED:-'true'} # From .env.all or default
      ETCD_DATA_DIR: ${ETCD_DATA_DIR:-'/var/lib/milvus/etcd'} # From .env.all or default
      COMMON_STORAGETYPE: ${COMMON_STORAGETYPE:-'local'} # From .env.all or default
    volumes:
      - milvus_data_standalone_all:/var/lib/milvus
      - ./embedEtcd.yaml:/milvus/configs/embedEtcd.yaml:ro
      - ./user.yaml:/milvus/configs/user.yaml:ro
    ports:
      - "${HOST_MILVUS_PORT:-19530}:19530"       # Milvus gRPC port
      - "${HOST_MILVUS_HTTP_PORT:-9091}:9091" # Milvus HTTP/RESTful API port
      - "2379:2379"                             # Exposed etcd port (if needed externally, usually not)
    command: ["milvus", "run", "standalone"]
    networks:
      - app_network
    restart: unless-stopped
    healthcheck:
      test: ["CMD-SHELL", "curl -f http://localhost:9091/healthz || exit 1"]
      interval: 30s
      timeout: 20s
      retries: 3
      start_period: 90s

  nginx:
    image: nginx:alpine
    container_name: minio_nginx_proxy_all
    ports:
      - "${HOST_MINIO_API_PORT:-9000}:80" # Map host's public MinIO API port to Nginx's port 80
    volumes:
      - ./nginx/minio.conf:/etc/nginx/conf.d/default.conf:ro # Mount custom Nginx config for MinIO
    networks:
      - app_network
    depends_on:
      - minio # Nginx depends on MinIO being started
    restart: unless-stopped

volumes:
  postgres_data_all:
  minio_data_all:
  redis_data_all:
  milvus_data_standalone_all:

networks:
  app_network:
    driver: bridge
    name: vector_meme_network_all # Giving the network a specific name
